# -*- coding: utf-8 -*-
"""all_code.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1txMOY-AOlzOtPrpKrfuHw5kDeyYxWc6i

# Data preparation

## Importing libraries
"""

from google.colab import drive
 drive.mount('/content/drive')

#import data manipulation and analysis packages
import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
from datetime import datetime as dt

#import tensorflow/keras packages (for autoencoder)
from keras.layers import Dense, Input, Conv2D, LSTM, MaxPool2D, UpSampling2D
from sklearn.model_selection import train_test_split
from keras.callbacks import EarlyStopping
from keras.utils import to_categorical
from numpy import argmax, array_equal
import matplotlib.pyplot as plt
from keras.models import Model
from imgaug import augmenters
from random import randint
from keras import Sequential
from keras import regularizers
from sklearn.manifold import TSNE
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import classification_report
from sklearn.metrics import accuracy_score
from sklearn import preprocessing

"""## Importing Dataset"""

# import data on 10/06/2022
df1 = pd.read_csv("SimData_221006_1.csv")
df2 = pd.read_csv("SimData_221006_2.csv")
df3 = pd.read_csv("SimData_221006_3.csv")
df4 = pd.read_csv("SimData_221006_4.csv")
df5 = pd.read_csv("SimData_221006_5.csv")
df6 = pd.read_csv("SimData_221006_6.csv")
df7 = pd.read_csv("SimData_221006_7.csv")
df8 = pd.read_csv("SimData_221006_8.csv")

# combine data on 10/06/2022
df_221006 = pd.concat([df1, df2], axis=0)
df_221006 = pd.concat([df_221006, df3], axis=0)
df_221006 = pd.concat([df_221006, df4], axis=0)
df_221006 = pd.concat([df_221006, df5], axis=0)
df_221006 = pd.concat([df_221006, df6], axis=0)
df_221006 = pd.concat([df_221006, df7], axis=0)
df_221006 = pd.concat([df_221006, df8], axis=0)

df_221006.shape

from google.colab import drive
drive.mount('/content/drive')

# import data on 10/20/2022
df1 = pd.read_csv("SimData_221020_1.csv")
df2 = pd.read_csv("SimData_221020_2.csv")
df3 = pd.read_csv("SimData_221020_3.csv")
df4 = pd.read_csv("SimData_221020_4.csv")
df5 = pd.read_csv("SimData_221020_5.csv")
df6 = pd.read_csv("SimData_221020_6.csv")

# combine data on 10/20/2022
df_221020 = pd.concat([df1, df2], axis=0)
df_221020 = pd.concat([df_221020, df3], axis=0)
df_221020 = pd.concat([df_221020, df4], axis=0)
df_221020 = pd.concat([df_221020, df5], axis=0)
df_221020 = pd.concat([df_221020, df6], axis=0)

df_221020.shape

# import data on 12/15/2022
df1 = pd.read_csv("SimData_221215_1.csv")
df2 = pd.read_csv("SimData_221215_2.csv")
df3 = pd.read_csv("SimData_221215_3.csv")

# combine data on 12/15/2022
df_221215 = pd.concat([df1, df2], axis=0)
df_221215 = pd.concat([df_221215, df3], axis=0)

df_221215.shape

# import data on 02/16/2023
df1 = pd.read_csv("SimData_230216_1.csv")
df2 = pd.read_csv("SimData_230216_2.csv")
df3 = pd.read_csv("SimData_230216_3.csv")
df4 = pd.read_csv("SimData_230216_4.csv")
df5 = pd.read_csv("SimData_230216_5.csv")
df6 = pd.read_csv("SimData_230216_6.csv")
df7 = pd.read_csv("SimData_230216_7.csv")
df8 = pd.read_csv("SimData_230216_8.csv")
df9 = pd.read_csv("SimData_230216_9.csv")
df10 = pd.read_csv("SimData_230216_10.csv")
df11 = pd.read_csv("SimData_230216_11.csv")
df12 = pd.read_csv("SimData_230216_12.csv")
df13 = pd.read_csv("SimData_230216_13.csv")
df14 = pd.read_csv("SimData_230216_14.csv")


# combine data on 02/16/2023
df_230216 = pd.concat([df1, df2], axis=0)
df_230216 = pd.concat([df_230216, df3], axis=0)
df_230216 = pd.concat([df_230216, df4], axis=0)
df_230216 = pd.concat([df_230216, df5], axis=0)
df_230216 = pd.concat([df_230216, df6], axis=0)
df_230216 = pd.concat([df_230216, df7], axis=0)
df_230216 = pd.concat([df_230216, df8], axis=0)
df_230216 = pd.concat([df_230216, df9], axis=0)
df_230216 = pd.concat([df_230216, df10], axis=0)
df_230216 = pd.concat([df_230216, df11], axis=0)
df_230216 = pd.concat([df_230216, df12], axis=0)
df_230216 = pd.concat([df_230216, df13], axis=0)
df_230216 = pd.concat([df_230216, df14], axis=0)

df_230216.shape

"""## Taking care of missing data"""

df_221006.isnull().sum().sum()

df_221020.isnull().sum().sum()

df_221215.isnull().sum().sum()

df_230216.isnull().sum().sum()

df_221215.columns[df_221215.isnull().any()]

df_230216.columns[df_230216.isnull().any()]



"""## Converting time zone"""

## convert time zone to UTC-1
df_221006['timestamp'] = pd.to_datetime(df_221006['timestamp'])
df_221006['timestamp'] = df_221006['timestamp'].dt.tz_convert('Etc/GMT+4')
df_221006.head()

## convert time zone to UTC-1
df_221020['timestamp'] = pd.to_datetime(df_221020['timestamp'])
df_221020['timestamp'] = df_221020['timestamp'].dt.tz_convert('Etc/GMT+4')
df_221020.head()

## convert time zone to UTC-5
df_221215['timestamp'] = pd.to_datetime(df_221215['timestamp'])
df_221215['timestamp'] = df_221215['timestamp'].dt.tz_convert('Etc/GMT+5')
df_221215.head()

## convert time zone to UTC-2
df_230216['timestamp'] = pd.to_datetime(df_230216['timestamp'])
df_230216['timestamp'] = df_230216['timestamp'].dt.tz_convert('Etc/GMT+5')
df_230216.head()

df_221006.to_csv("SimData_df221006.csv", index=False)
df_221020.to_csv("SimData_df221020.csv", index=False)
df_221215.to_csv("SimData_df221215.csv", index=False)
df_230216.to_csv("SimData_df230216.csv", index=False)

"""## Labelling s-turn (manually)"""

df_221006 = pd.read_csv("SimData_df221006.csv")
df_221020 = pd.read_csv("SimData_df221020.csv")
df_221215 = pd.read_csv("SimData_df221215.csv")
df_230216 = pd.read_csv("SimData_df230216.csv")

## convert to datetime index
df_221006['timeidx'] = pd.to_datetime(df_221006['timestamp'])
df_221006 = df_221006.set_index('timeidx')

df_221020['timeidx'] = pd.to_datetime(df_221020['timestamp'])
df_221020 = df_221020.set_index('timeidx')

df_221215['timeidx'] = pd.to_datetime(df_221215['timestamp'])
df_221215 = df_221215.set_index('timeidx')

df_230216['timeidx'] = pd.to_datetime(df_230216['timestamp'])
df_230216 = df_230216.set_index('timeidx')

list(df_221006.columns)

## sTurn features: surfaceWindDirection, surfaceWindSpeed, gpsAltitude, groundSpeed, angleOfAttack

ttotal = df_221020.between_time(start_time = '15:00:00', end_time = '15:20:00')
tstart = df_221020.between_time(start_time = '15:03:00', end_time = '15:06:00')
tend = df_221020.between_time(start_time = '15:13:00', end_time = '15:14:00')

f, axarr = plt.subplots(3, 3, figsize=(10,10), sharex='col')

sns.lineplot(x = ttotal.index, y = ttotal.surfaceWindDirection, color = 'blue', label = 'surfaceWindDirection', ax=axarr[0][0])
sns.lineplot(x = ttotal.index, y = ttotal.surfaceWindSpeed, color = 'green', label = 'surfaceWindSpeed', ax=axarr[0][0])
sns.lineplot(x = ttotal.index, y = ttotal.gpsAltitude, color = 'yellow', label = 'gpsAltitude', ax=axarr[1][0])
sns.lineplot(x = ttotal.index, y = ttotal.groundSpeed, color = 'red', label = 'groundSpeed', ax=axarr[1][0])
sns.lineplot(x = ttotal.index, y = ttotal.angleOfAttack, color = 'black', label = 'angleOfAttack', ax=axarr[2][0])

sns.lineplot(x = tstart.index, y = tstart.surfaceWindDirection, color = 'blue', label = 'surfaceWindDirection', ax=axarr[0][1])
sns.lineplot(x = tstart.index, y = tstart.surfaceWindSpeed, color = 'green', label = 'surfaceWindSpeed', ax=axarr[0][1])
sns.lineplot(x = tstart.index, y = tstart.gpsAltitude, color = 'yellow', label = 'gpsAltitude', ax=axarr[1][1])
sns.lineplot(x = tstart.index, y = tstart.groundSpeed, color = 'red', label = 'groundSpeed', ax=axarr[1][1])
sns.lineplot(x = tstart.index, y = tstart.angleOfAttack, color = 'black', label = 'angleOfAttack', ax=axarr[2][1])

sns.lineplot(x = tend.index, y = tend.surfaceWindDirection, color = 'blue', label = 'surfaceWindDirection', ax=axarr[0][2])
sns.lineplot(x = tend.index, y = tend.surfaceWindSpeed, color = 'green', label = 'surfaceWindSpeed', ax=axarr[0][2])
sns.lineplot(x = tend.index, y = tend.gpsAltitude, color = 'yellow', label = 'gpsAltitude', ax=axarr[1][2])
sns.lineplot(x = tend.index, y = tend.groundSpeed, color = 'red', label = 'groundSpeed', ax=axarr[1][2])
sns.lineplot(x = tend.index, y = tend.angleOfAttack, color = 'black', label = 'angleOfAttack', ax=axarr[2][2])

for ax in axarr[:, 0]:
    plt.setp(ax.get_xticklabels(), rotation=90)

for ax in axarr.flat:
    plt.sca(ax)
    plt.xticks(rotation=90)

f.suptitle("S-Turn on 10/20/2022")
plt.show()

### label the start time of s-turn as 15:04:15
### label the end time of s-turn as 15:13:50

## sTurn features: surfaceWindDirection, surfaceWindSpeed, gpsAltitude, groundSpeed, angleOfAttack

ttotal = df_221215.between_time(start_time = '13:15:00', end_time = '13:50:00')
tstart = df_221215.between_time(start_time = '13:27:00', end_time = '13:28:00')
tend = df_221215.between_time(start_time = '13:38:00', end_time = '13:39:00')

f, axarr = plt.subplots(3, 3, figsize=(10,10), sharex='col')

sns.lineplot(x = ttotal.index, y = ttotal.surfaceWindDirection, color = 'blue', label = 'surfaceWindDirection', ax=axarr[0][0])
sns.lineplot(x = ttotal.index, y = ttotal.surfaceWindSpeed, color = 'green', label = 'surfaceWindSpeed', ax=axarr[0][0])
sns.lineplot(x = ttotal.index, y = ttotal.gpsAltitude, color = 'yellow', label = 'gpsAltitude', ax=axarr[1][0])
sns.lineplot(x = ttotal.index, y = ttotal.groundSpeed, color = 'red', label = 'groundSpeed', ax=axarr[1][0])
sns.lineplot(x = ttotal.index, y = ttotal.angleOfAttack, color = 'black', label = 'angleOfAttack', ax=axarr[2][0])

sns.lineplot(x = tstart.index, y = tstart.surfaceWindDirection, color = 'blue', label = 'surfaceWindDirection', ax=axarr[0][1])
sns.lineplot(x = tstart.index, y = tstart.surfaceWindSpeed, color = 'green', label = 'surfaceWindSpeed', ax=axarr[0][1])
sns.lineplot(x = tstart.index, y = tstart.gpsAltitude, color = 'yellow', label = 'gpsAltitude', ax=axarr[1][1])
sns.lineplot(x = tstart.index, y = tstart.groundSpeed, color = 'red', label = 'groundSpeed', ax=axarr[1][1])
sns.lineplot(x = tstart.index, y = tstart.angleOfAttack, color = 'black', label = 'angleOfAttack', ax=axarr[2][1])

sns.lineplot(x = tend.index, y = tend.surfaceWindDirection, color = 'blue', label = 'surfaceWindDirection', ax=axarr[0][2])
sns.lineplot(x = tend.index, y = tend.surfaceWindSpeed, color = 'green', label = 'surfaceWindSpeed', ax=axarr[0][2])
sns.lineplot(x = tend.index, y = tend.gpsAltitude, color = 'yellow', label = 'gpsAltitude', ax=axarr[1][2])
sns.lineplot(x = tend.index, y = tend.groundSpeed, color = 'red', label = 'groundSpeed', ax=axarr[1][2])
sns.lineplot(x = tend.index, y = tend.angleOfAttack, color = 'black', label = 'angleOfAttack', ax=axarr[2][2])

for ax in axarr[:, 0]:
    plt.setp(ax.get_xticklabels(), rotation=90)

for ax in axarr.flat:
    plt.sca(ax)
    plt.xticks(rotation=90)

f.suptitle("S-Turn on 12/15/2022")
plt.show()

### label the start time of s-turn as 13:27:10
### label the end time of s-turn as 13:38:30

## sTurn features: surfaceWindDirection, surfaceWindSpeed, gpsAltitude, groundSpeed, angleOfAttack

ttotal = df_230216.between_time(start_time = '9:20:00', end_time = '9:35:00')
tstart = df_230216.between_time(start_time = '9:24:00', end_time = '9:26:00')
tend = df_230216.between_time(start_time = '9:29:00', end_time = '9:31:00')

f, axarr = plt.subplots(3, 3, figsize=(10,10), sharex='col')

sns.lineplot(x = ttotal.index, y = ttotal.surfaceWindDirection, color = 'blue', label = 'surfaceWindDirection', ax=axarr[0][0])
sns.lineplot(x = ttotal.index, y = ttotal.surfaceWindSpeed, color = 'green', label = 'surfaceWindSpeed', ax=axarr[0][0])
sns.lineplot(x = ttotal.index, y = ttotal.gpsAltitude, color = 'yellow', label = 'gpsAltitude', ax=axarr[1][0])
sns.lineplot(x = ttotal.index, y = ttotal.groundSpeed, color = 'red', label = 'groundSpeed', ax=axarr[1][0])
sns.lineplot(x = ttotal.index, y = ttotal.angleOfAttack, color = 'black', label = 'angleOfAttack', ax=axarr[2][0])

sns.lineplot(x = tstart.index, y = tstart.surfaceWindDirection, color = 'blue', label = 'surfaceWindDirection', ax=axarr[0][1])
sns.lineplot(x = tstart.index, y = tstart.surfaceWindSpeed, color = 'green', label = 'surfaceWindSpeed', ax=axarr[0][1])
sns.lineplot(x = tstart.index, y = tstart.gpsAltitude, color = 'yellow', label = 'gpsAltitude', ax=axarr[1][1])
sns.lineplot(x = tstart.index, y = tstart.groundSpeed, color = 'red', label = 'groundSpeed', ax=axarr[1][1])
sns.lineplot(x = tstart.index, y = tstart.angleOfAttack, color = 'black', label = 'angleOfAttack', ax=axarr[2][1])

sns.lineplot(x = tend.index, y = tend.surfaceWindDirection, color = 'blue', label = 'surfaceWindDirection', ax=axarr[0][2])
sns.lineplot(x = tend.index, y = tend.surfaceWindSpeed, color = 'green', label = 'surfaceWindSpeed', ax=axarr[0][2])
sns.lineplot(x = tend.index, y = tend.gpsAltitude, color = 'yellow', label = 'gpsAltitude', ax=axarr[1][2])
sns.lineplot(x = tend.index, y = tend.groundSpeed, color = 'red', label = 'groundSpeed', ax=axarr[1][2])
sns.lineplot(x = tend.index, y = tend.angleOfAttack, color = 'black', label = 'angleOfAttack', ax=axarr[2][2])

for ax in axarr[:, 0]:
    plt.setp(ax.get_xticklabels(), rotation=90)

for ax in axarr.flat:
    plt.sca(ax)
    plt.xticks(rotation=90)

f.suptitle("S-Turn on 02/06/2023")
plt.show()

### label the start time of s-turn as 9:25:00
### label the end time of s-turn as 9:30:00

"""## Labelling quick-stop (manually)"""

# quick stop features: gpsAltitude, mainRotorRpm, groundSpeed, collectivePosition, antiTorquePedalPosition, pitch 

ttotal = df_221215.between_time(start_time = '13:50:00', end_time = '14:15:00')
tstart = df_221215.between_time(start_time = '13:56:00', end_time = '13:58:00')
tend = df_221215.between_time(start_time = '14:01:00', end_time = '14:02:00')

f, axarr = plt.subplots(3, 3, figsize=(10, 10), sharex='col')
plt.subplots_adjust(hspace=0.5)

sns.lineplot(x = ttotal.index, y = ttotal.gpsAltitude, color = 'blue', label = 'gpsAltitude', ax=axarr[0][0])
sns.lineplot(x = ttotal.index, y = ttotal.mainRotorRpm, color = 'green', label = 'mainRotorRpm', ax=axarr[1][0])
sns.lineplot(x = ttotal.index, y = ttotal.groundSpeed, color = 'cyan', label = 'groundSpeed', ax=axarr[2][0])
sns.lineplot(x = ttotal.index, y = ttotal.collectivePosition, color = 'red', label = 'collectivePosition', ax=axarr[2][0])
sns.lineplot(x = ttotal.index, y = ttotal.antiTorquePedalPosition, color = 'black', label = 'antiTorquePedalPosition', ax=axarr[2][0])
sns.lineplot(x = ttotal.index, y = ttotal.pitch, color = 'magenta', label = 'pitch', ax=axarr[1][0])

sns.lineplot(x = tstart.index, y = tstart.gpsAltitude, color = 'blue', label = 'gpsAltitude', ax=axarr[0][1])
sns.lineplot(x = tstart.index, y = tstart.mainRotorRpm, color = 'green', label = 'mainRotorRpm', ax=axarr[1][1])
sns.lineplot(x = tstart.index, y = tstart.groundSpeed, color = 'cyan', label = 'groundSpeed', ax=axarr[2][1])
sns.lineplot(x = tstart.index, y = tstart.collectivePosition, color = 'red', label = 'collectivePosition', ax=axarr[2][1])
sns.lineplot(x = tstart.index, y = tstart.antiTorquePedalPosition, color = 'black', label = 'antiTorquePedalPosition', ax=axarr[2][1])
sns.lineplot(x = tstart.index, y = tstart.pitch, color = 'magenta', label = 'pitch', ax=axarr[1][1])

sns.lineplot(x = tend.index, y = tend.gpsAltitude, color = 'blue', label = 'gpsAltitude', ax=axarr[0][2])
sns.lineplot(x = tend.index, y = tend.mainRotorRpm, color = 'green', label = 'mainRotorRpm', ax=axarr[1][2])
sns.lineplot(x = tend.index, y = tend.groundSpeed, color = 'cyan', label = 'groundSpeed', ax=axarr[2][2])
sns.lineplot(x = tend.index, y = tend.collectivePosition, color = 'red', label = 'collectivePosition', ax=axarr[2][2])
sns.lineplot(x = tend.index, y = tend.antiTorquePedalPosition, color = 'black', label = 'antiTorquePedalPosition', ax=axarr[2][2])
sns.lineplot(x = tend.index, y = tend.pitch, color = 'magenta', label = 'pitch', ax=axarr[1][2])

for ax in axarr[:, 0]:
    plt.setp(ax.get_xticklabels(), rotation=90)

for ax in axarr.flat:
    plt.sca(ax)
    plt.xticks(rotation=90)

f.suptitle("Quick Stop on 12/15/2022")
plt.show()


### label the start time of quick-stop as 13:56:30
### label the end time of quick-stop as 14:01:10

# quick stop features: gpsAltitude, mainRotorRpm, groundSpeed, collectivePosition, antiTorquePedalPosition, pitch 

ttotal = df_230216.between_time(start_time = '9:50:00', end_time = '10:30:00')
tstart = df_230216.between_time(start_time = '10:07:00', end_time = '10:09:00')
tend = df_230216.between_time(start_time = '10:09:00', end_time = '10:11:00')

f, axarr = plt.subplots(3, 3, figsize=(10, 10), sharex='col')
plt.subplots_adjust(hspace=0.5)

sns.lineplot(x = ttotal.index, y = ttotal.gpsAltitude, color = 'blue', label = 'gpsAltitude', ax=axarr[0][0])
sns.lineplot(x = ttotal.index, y = ttotal.mainRotorRpm, color = 'green', label = 'mainRotorRpm', ax=axarr[1][0])
sns.lineplot(x = ttotal.index, y = ttotal.groundSpeed, color = 'cyan', label = 'groundSpeed', ax=axarr[2][0])
sns.lineplot(x = ttotal.index, y = ttotal.collectivePosition, color = 'red', label = 'collectivePosition', ax=axarr[2][0])
sns.lineplot(x = ttotal.index, y = ttotal.antiTorquePedalPosition, color = 'black', label = 'antiTorquePedalPosition', ax=axarr[2][0])
sns.lineplot(x = ttotal.index, y = ttotal.pitch, color = 'magenta', label = 'pitch', ax=axarr[1][0])

sns.lineplot(x = tstart.index, y = tstart.gpsAltitude, color = 'blue', label = 'gpsAltitude', ax=axarr[0][1])
sns.lineplot(x = tstart.index, y = tstart.mainRotorRpm, color = 'green', label = 'mainRotorRpm', ax=axarr[1][1])
sns.lineplot(x = tstart.index, y = tstart.groundSpeed, color = 'cyan', label = 'groundSpeed', ax=axarr[2][1])
sns.lineplot(x = tstart.index, y = tstart.collectivePosition, color = 'red', label = 'collectivePosition', ax=axarr[2][1])
sns.lineplot(x = tstart.index, y = tstart.antiTorquePedalPosition, color = 'black', label = 'antiTorquePedalPosition', ax=axarr[2][1])
sns.lineplot(x = tstart.index, y = tstart.pitch, color = 'magenta', label = 'pitch', ax=axarr[1][1])

sns.lineplot(x = tend.index, y = tend.gpsAltitude, color = 'blue', label = 'gpsAltitude', ax=axarr[0][2])
sns.lineplot(x = tend.index, y = tend.mainRotorRpm, color = 'green', label = 'mainRotorRpm', ax=axarr[1][2])
sns.lineplot(x = tend.index, y = tend.groundSpeed, color = 'cyan', label = 'groundSpeed', ax=axarr[2][2])
sns.lineplot(x = tend.index, y = tend.collectivePosition, color = 'red', label = 'collectivePosition', ax=axarr[2][2])
sns.lineplot(x = tend.index, y = tend.antiTorquePedalPosition, color = 'black', label = 'antiTorquePedalPosition', ax=axarr[2][2])
sns.lineplot(x = tend.index, y = tend.pitch, color = 'magenta', label = 'pitch', ax=axarr[1][2])

for ax in axarr[:, 0]:
    plt.setp(ax.get_xticklabels(), rotation=90)

for ax in axarr.flat:
    plt.sca(ax)
    plt.xticks(rotation=90)

f.suptitle("Quick Stop on 02/06/2023")
plt.show()


### label the start time of quick stop as 
### label the end time of quick stop as

"""## Importing labeled data"""

df1 = pd.read_csv("SimData_df221006_label.csv")
df2 = pd.read_csv("SimData_df221020_label.csv")
df3 = pd.read_csv("SimData_df221215_label.csv")
df4 = pd.read_csv("SimData_df230216_label.csv")

"""## Combining dataset"""

print(df1.shape, df2.shape, df3.shape, df4.shape)

print(df1.seconds.min(), df1.seconds.max())

print(df2.seconds.min(), df2.seconds.max())

print(df3.seconds.min(), df3.seconds.max())

print(df4.seconds.min(), df4.seconds.max())

df = pd.concat([df1, df2], axis=0)
df = pd.concat([df, df3], axis=0)
df = pd.concat([df, df4], axis=0)

df.head()

"""## Taking care of missing data / null label"""

df.shape

df.columns[df.isnull().any()]

df['e1FuelFlowRate'].isnull().sum()

df['e2FuelFlowRate'].isnull().sum()

df['hasGeneratorFailureWarning'].isnull().sum()

df['e1FuelFlowRatePerMin'].isnull().sum()

df['e2FuelFlowRatePerMin'].isnull().sum()

# remove columns with high percentage of missing data
to_drop = ['e1FuelFlowRate', 'e2FuelFlowRate', 'e1FuelFlowRatePerMin', 'e2FuelFlowRatePerMin']
df = df.drop(to_drop, axis=1)
df.shape

# fill columns with low percentage of missing data with median
to_fill = df['hasGeneratorFailureWarning'].value_counts().index[0]
df['hasGeneratorFailureWarning'] = df['hasGeneratorFailureWarning'].fillna(to_fill)

df['label'].isnull().sum()

df['label'] = df['label'].fillna('other')

df['label'].value_counts()

df['label'] = df['label'].replace('s-turn', 'sTurn')
df['label'] = df['label'].replace('quickstop', 'quickStop')
df['label'] = df['label'].replace('qucikStop', 'quickStop')
df['label'] = df['label'].replace('low recon', 'lowRecon')
df['label'] = df['label'].replace('high recon', 'highRecon')
df['label'].value_counts()

df.to_csv("SimData_all4_label.csv", index=False)

"""## Reducing dimension v1 -physics base"""

phy_param = ['timestamp', 'latitude', 'longitude', 'gpsAltitude', 'absoluteAltitude', 'trueHeading', 'pitch', 'roll', 'yaw', 'groundSpeed', 'trueAirspeed', 'climbOrDescentRate', 'pilotRadioAltitude', 'copilotRadioAltitude', 'groundTrack', 'rollRate', 'pitchRate', 'yawRate', 'turnRate to degPerSec', 'angleOfAttack', 'rollAcceleration', 'pitchAcceleration', 'yawAcceleration', 'normalAcceleration', 'lateralAcceleration', 'longitudinalAcceleration', 'collectivePosition','antiTorquePedalPosition', 'throttlePosition', 'hasParkingBrakeEngaged', 'hasLandingGearDown', 'hasRotorBrakeEngaged', 'mainRotorRpm', 'tailRotorRpm', 'mainRotorTorque', 'surfaceWindDirection', 'label']
df = df[phy_param]
df.shape

df.to_csv("SimData_all4_label_drPhy.csv", index=False)

"""## Reducing dimension v2 -PCA"""

# Importing the dataset
df = pd.read_csv("SimData_all4_label.csv")

df.head()

df.insert(0, 'seconds', df.pop('seconds'))

# remove redundant time columns
to_drop = ['_id', 'date', 'time', 'gpsDateTime', 'timestamp']
df = df.drop(to_drop, axis=1)

df.dtypes.value_counts()

df.select_dtypes(include=object)

df['autoPilotMode'].value_counts()

# remove unrelated object columns

to_drop = ['autoPilotMode']
df = df.drop(to_drop, axis=1)

df.shape

### insert PCA component selection

X = df.iloc[:, :-1].values
y = df.iloc[:, -1].values

# Splitting the dataset into the Training set and Test set
from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2, random_state = 0)

# Feature Scaling
from sklearn.preprocessing import StandardScaler
sc = StandardScaler()
X_train = sc.fit_transform(X_train)
X_test = sc.transform(X_test)

# Applying PCA
from sklearn.decomposition import PCA
pca = PCA(n_components = 100)    #100
X_train = pca.fit_transform(X_train)
X_test = pca.transform(X_test)

# Training the Logistic Regression model on the Training set
from sklearn.linear_model import LogisticRegression
classifier = LogisticRegression(random_state = 0)
classifier.fit(X_train, y_train)

# Making the Confusion Matrix
from sklearn.metrics import confusion_matrix, accuracy_score
y_pred = classifier.predict(X_test)
cm = confusion_matrix(y_test, y_pred)
print(cm)
accuracy_score(y_test, y_pred)

PC_values = np.arange(pca.n_components_) + 1
plt.plot(PC_values, pca.explained_variance_ratio_, 'o-', linewidth=2, color='blue')
plt.title('Scree Plot')
plt.xlabel('Principal Component')
plt.ylabel('Variance Explained')
plt.xticks(np.arange(0, 100, step=5))
plt.show()

### choose 35/10 components

"""### Applying PCA to the entire data with the determined n-components"""

X = df.iloc[:, :-1].values
y = df.iloc[:, -1].values

## Feature Scaling
from sklearn.preprocessing import StandardScaler
sc = StandardScaler()
X = sc.fit_transform(X)

## Applying PCA with 35 components
from sklearn.decomposition import PCA
pca_35 = PCA(n_components = 35)   #35
X_35 = pca_35.fit_transform(X)

## convert to dataframe

X_35 = pd.DataFrame(X_35)
new_cols = {}
for i in range(35):
    if i == 0:
        new_cols[i] = 'time'
    else:
        new_cols[i] = f'V{i}'
X_35 = X_35.rename(columns=new_cols)

y = pd.DataFrame(y, columns=['label'])

df_PCA_35 = pd.concat([X_35, y], axis=1)

df_PCA_35.head()

df_PCA_35.to_csv("SimData_all4_label_drPCA35.csv", index=False)

## Applying PCA with 15 components
from sklearn.decomposition import PCA
pca_15 = PCA(n_components = 15)   
X_15 = pca_15.fit_transform(X)

## convert to dataframe

X_15 = pd.DataFrame(X_15)
new_cols = {}
for i in range(15):
    if i == 0:
        new_cols[i] = 'time'
    else:
        new_cols[i] = f'V{i}'
X_15 = X_15.rename(columns=new_cols)

y = pd.DataFrame(y, columns=['label'])

df_PCA_15 = pd.concat([X_15, y], axis=1)

df_PCA_15.head()

df_PCA_15.to_csv("SimData_all4_label_drPCA15.csv", index=False)

"""## Auto Encoders"""

#T-SNE plot code for visualizing high dimensional data (currently unused)

def tsne_plot(x1, y1, name="graph.png"):
    tsne = TSNE(n_components=2, random_state=0)
    X_t = tsne.fit_transform(x1)

    plt.figure(figsize=(12, 8))
    plt.scatter(X_t[np.where(y1 == 0), 0], X_t[np.where(y1 == 0), 1], marker='o', color='g', linewidth=1, alpha=0.8, label='other')
    plt.scatter(X_t[np.where(y1 == 1), 0], X_t[np.where(y1 == 1), 1], marker='o', color='r', linewidth=1, alpha=0.8, label='sTurn')
    plt.scatter(X_t[np.where(y1 == 2), 0], X_t[np.where(y1 == 2), 1], marker='o', color='b', linewidth=1, alpha=0.8, label='quickStop')
    plt.scatter(X_t[np.where(y1 == 3), 0], X_t[np.where(y1 == 3), 1], marker='o', color='c', linewidth=1, alpha=0.8, label='lowRecon')
    plt.scatter(X_t[np.where(y1 == 4), 0], X_t[np.where(y1 == 4), 1], marker='o', color='m', linewidth=1, alpha=0.8, label='highRecon')

    plt.legend(loc='best');
    #plt.savefig(name);
    plt.show();

df15 = pd.read_csv('/content/drive/MyDrive/daen690_datapirates/SimData_all4_label_drPCA15.csv')
df35 = pd.read_csv('/content/drive/MyDrive/daen690_datapirates/SimData_all4_label_drPCA35.csv')
# data = pd.read_csv('SimData_all4_label_drPCA15.csv.csv')
#df15 = pd.read_csv('SimData_all4_label_drPCA15.csv')
#df35 = pd.read_csv('SimData_all4_label_drPCA35.csv')

data = df15

data.head()

data.dtypes



vc = data['label'].value_counts().to_frame().reset_index()
vc['percent'] = vc["label"].apply(lambda x : round(100*float(x) / len(data), 2))
vc = vc.rename(columns = {"index" : "Target", "Class" : "Count"})
vc

data.label.unique()
lab = []
for i in data.label:
    if i == 'other':
        lab.append(0)
    elif i == 'sTurn':
        lab.append(1)
    elif i == 'quickStop':
        lab.append(2)
    elif i == 'lowRecon':
        lab.append(3)
    elif i == 'highRecon':
        lab.append(4)


data.label = lab

data

X = data.drop(['label'], axis = 1).values
Y = data["label"].values

# tsne_plot(X, Y, "original.png")

## input layer 
input_layer = Input(shape=(X.shape[1],))

## encoding part
encoded = Dense(100, activation='tanh', activity_regularizer=regularizers.l1(10e-5))(input_layer)
encoded = Dense(50, activation='relu')(encoded)

## decoding part
decoded = Dense(50, activation='tanh')(encoded)
decoded = Dense(100, activation='tanh')(decoded)

## output layer
output_layer = Dense(X.shape[1], activation='relu')(decoded)

autoencoder = Model(input_layer, output_layer)
autoencoder.compile(optimizer="adadelta", loss="mse")

data.head()

x = data.drop('label', axis = 1)
y = data['label']

x_scale = preprocessing.MinMaxScaler().fit_transform(x.values)
x_norm, x_st, x_qs, x_lr, x_hr = x_scale[y == 0], x_scale[y == 1], x_scale[y == 2], x_scale[y == 3], x_scale[y == 4]

index = np.random.choice(len(x_norm), size = 5000) # size=5000, LogisticRegression_accuracy=88.42%
# index = np.random.choice(len(x_norm), size = 430000) # size=430000, LogisticRegression_accuracy=79.68%

x_norm_train = x_norm[index]

autoencoder.fit(x_norm_train, x_norm_train, 
                batch_size = 256, epochs = 90, 
                shuffle = True, validation_split = 0.20);

hidden_representation = Sequential()
hidden_representation.add(autoencoder.layers[0])
hidden_representation.add(autoencoder.layers[1])
hidden_representation.add(autoencoder.layers[2])

norm_hid_rep = hidden_representation.predict(x_norm[~index])
st_hid_rep = hidden_representation.predict(x_st)
qs_hid_rep = hidden_representation.predict(x_qs)
lr_hid_rep = hidden_representation.predict(x_lr)
hr_hid_rep = hidden_representation.predict(x_hr)

#This takes the hidden weights and applies to our testing data to attempt to classify

rep_x = np.append(norm_hid_rep,qs_hid_rep, axis = 0)
rep_x = np.append(rep_x, st_hid_rep, axis = 0)
rep_x = np.append(rep_x, lr_hid_rep, axis = 0)
rep_x = np.append(rep_x, hr_hid_rep, axis = 0)
y_n = np.zeros(norm_hid_rep.shape[0])
y_st = np.ones(st_hid_rep.shape[0])
y_qs = np.full(qs_hid_rep.shape[0],2)
y_lr = np.full(lr_hid_rep.shape[0],3)
y_hr = np.full(hr_hid_rep.shape[0],4)



rep_y = np.append(y_n,y_st, axis = 0)
rep_y = np.append(rep_y,y_qs, axis = 0)
rep_y = np.append(rep_y,y_lr, axis = 0)
rep_y = np.append(rep_y,y_hr,axis = 0)

rep_y.shape

"""## Classification"""

# LogisticRegression
train_x, val_x, train_y, val_y = train_test_split(rep_x, rep_y, test_size=0.25)
clf = LogisticRegression(solver="lbfgs").fit(train_x, train_y)
pred_y = clf.predict(val_x);

print ("")
print ("Classification Report: ")
print (classification_report(val_y, pred_y))

print ("")
print ("Accuracy Score: ", accuracy_score(val_y, pred_y))

# Random Forest
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.model_selection import cross_val_score

train_x, val_x, train_y, val_y = train_test_split(rep_x, rep_y, test_size=0.25)
rf =RandomForestClassifier(n_estimators=10)
rf.fit(train_x, train_y)
pred_y = rf.predict(val_x);

print ("")
print ("Classification Report: ")
print (classification_report(val_y, pred_y))

print ("")
print ("Accuracy Score: ", accuracy_score(val_y, pred_y))

# KNN 
from sklearn.neighbors import KNeighborsClassifier
from sklearn.model_selection import cross_val_score
import numpy as np

train_x, val_x, train_y, val_y = train_test_split(rep_x, rep_y, test_size=0.25)
knn = KNeighborsClassifier(n_neighbors = 10)
knn.fit(train_x, train_y)
pred_y = rf.predict(val_x);

print ("")
print ("Classification Report: ")
print (classification_report(val_y, pred_y))

print ("")
print ("Accuracy Score: ", accuracy_score(val_y, pred_y))

# SVM
from sklearn import svm
train_x, val_x, train_y, val_y = train_test_split(rep_x, rep_y, test_size=0.25)
clf = svm.SVC(kernel='linear')
clf.fit(train_x, train_y)
pred_y = clf.predict(val_x);

print ("")
print ("Classification Report: ")
print (classification_report(val_y, pred_y))

print ("")
print ("Accuracy Score: ", accuracy_score(val_y, pred_y))

# Naive Bayes
from sklearn.naive_bayes import GaussianNB
train_x, val_x, train_y, val_y = train_test_split(rep_x, rep_y, test_size=0.25)
gnb = GaussianNB()
gnb.fit(train_x, train_y)
pred_y = clf.predict(val_x);

print ("")
print ("Classification Report: ")
print (classification_report(val_y, pred_y))

print ("")
print ("Accuracy Score: ", accuracy_score(val_y, pred_y))

"""## Testing the classification w/o autoencoder"""

# LogisticRegression
train_x, val_x, train_y, val_y = train_test_split(X, Y, test_size=0.25)
clf = LogisticRegression(solver="lbfgs").fit(train_x, train_y)
pred_y = clf.predict(val_x);

print ("")
print ("Classification Report: ")
print (classification_report(val_y, pred_y))

print ("")
print ("Accuracy Score: ", accuracy_score(val_y, pred_y))

# Random Forest
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.model_selection import cross_val_score

train_x, val_x, train_y, val_y = train_test_split(X, Y, test_size=0.25)
rf =RandomForestClassifier(n_estimators=10)
rf.fit(train_x, train_y)
pred_y = rf.predict(val_x);

print ("")
print ("Classification Report: ")
print (classification_report(val_y, pred_y))

print ("")
print ("Accuracy Score: ", accuracy_score(val_y, pred_y))

# KNN 
from sklearn.neighbors import KNeighborsClassifier
from sklearn.model_selection import cross_val_score
import numpy as np

train_x, val_x, train_y, val_y = train_test_split(X, Y, test_size=0.25)
knn = KNeighborsClassifier(n_neighbors = 10)
knn.fit(train_x, train_y)
pred_y = rf.predict(val_x);

print ("")
print ("Classification Report: ")
print (classification_report(val_y, pred_y))

print ("")
print ("Accuracy Score: ", accuracy_score(val_y, pred_y))

# SVM
from sklearn import svm
train_x, val_x, train_y, val_y = train_test_split(X, Y, test_size=0.25)
clf = svm.SVC(kernel='linear')
clf.fit(train_x, train_y)
pred_y = clf.predict(val_x);

print ("")
print ("Classification Report: ")
print (classification_report(val_y, pred_y))

print ("")
print ("Accuracy Score: ", accuracy_score(val_y, pred_y))

# Naive Bayes
from sklearn.naive_bayes import GaussianNB
train_x, val_x, train_y, val_y = train_test_split(X, Y, test_size=0.25)
gnb = GaussianNB()
gnb.fit(train_x, train_y)
pred_y = gnb.predict(val_x);

print ("")
print ("Classification Report: ")
print (classification_report(val_y, pred_y))

print ("")
print ("Accuracy Score: ", accuracy_score(val_y, pred_y))

val_y.shape



"""## Testing physics dataset w/o autoencoder"""

dfphy = pd.read_csv('SimData_all4_label_drPhy.csv')

# Feature Scaling for dfphy only, rerun with each new algorithm
from sklearn.preprocessing import StandardScaler
train_x, val_x, train_y, val_y = train_test_split(X, Y, test_size=0.25)
sc = StandardScaler()
train_x = sc.fit_transform(train_x)
val_x = sc.transform(val_x)

# LogisticRegression
# train_x, val_x, train_y, val_y = train_test_split(X, Y, test_size=0.25)
clf = LogisticRegression(solver="lbfgs").fit(train_x, train_y)
pred_y = clf.predict(val_x)

print ("")
print ("Classification Report: ")
print (classification_report(val_y, pred_y))

print ("")
print ("Accuracy Score: ", accuracy_score(val_y, pred_y))

# Random Forest
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.model_selection import cross_val_score

# train_x, val_x, train_y, val_y = train_test_split(X, Y, test_size=0.25)
rf =RandomForestClassifier(n_estimators=10)
rf.fit(train_x, train_y)
pred_y = rf.predict(val_x);

print ("")
print ("Classification Report: ")
print (classification_report(val_y, pred_y))

print ("")
print ("Accuracy Score: ", accuracy_score(val_y, pred_y))

# KNN 
from sklearn.neighbors import KNeighborsClassifier
from sklearn.model_selection import cross_val_score
import numpy as np

train_x, val_x, train_y, val_y = train_test_split(X, Y, test_size=0.25)
knn = KNeighborsClassifier(n_neighbors = 10)
knn.fit(train_x, train_y)
pred_y = rf.predict(val_x);

print ("")
print ("Classification Report: ")
print (classification_report(val_y, pred_y))

print ("")
print ("Accuracy Score: ", accuracy_score(val_y, pred_y))

# SVM
from sklearn import svm
# train_x, val_x, train_y, val_y = train_test_split(X, Y, test_size=0.25)
clf = svm.SVC(kernel='linear')
clf.fit(train_x, train_y)
pred_y = clf.predict(val_x);

print ("")
print ("Classification Report: ")
print (classification_report(val_y, pred_y))

print ("")
print ("Accuracy Score: ", accuracy_score(val_y, pred_y))

# Naive Bayes
from sklearn.naive_bayes import GaussianNB
# train_x, val_x, train_y, val_y = train_test_split(X, Y, test_size=0.25)
gnb = GaussianNB()
gnb.fit(train_x, train_y)
pred_y = gnb.predict(val_x);

print ("")
print ("Classification Report: ")
print (classification_report(val_y, pred_y))

print ("")
print ("Accuracy Score: ", accuracy_score(val_y, pred_y))

